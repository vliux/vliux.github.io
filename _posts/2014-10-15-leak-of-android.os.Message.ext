---
layout: post
title:  "Leak of android.os.Message"
date:   2014-10-15 15:50:00
categories: Blog, Android
excerpt: Explore into Handler and Message, which could make your Andorid applicaion memory leak.
comments: true
---
It's quite normal for an Android application developer to write such code:
{% highlight java %}
public class MyActivity extends Activity {
    private final static int WHAT_SOMETHING = 1;
    private final Handler mSomeHandler = new Handler(){
        public void handleMessage(Message msg){
            switch(msg.what){
                case WHAT_SOMETHING:
                    // some calculation
                    break;
            }
        }
    }
    
    public void doSomething(){
        // some business or UI logic
        mSomeHandler.sendEmptyMessage(WHAT_SOMETHING);
    }
}
{% endhighlight %}
<br><br>
At first glance the code above doesn't have any flaw. But later when you are at integration test (monkey test in our real case), you may get into an OOM exception. After investigation on the hprof file, you find that the entire Activity is referernced by one or multiple Message objects which prevents it from GC.
<br><br>
"Well, that's good! I will remove all the messages in the MessageQueue when activity is being destroyed." So you add the following code to your activity:
{% highlight java %}
protected void onDestroy(){
    mSomeHandler.removeMessage(WHAT_SOMETHING);
}
{% endhighlight %}
<br><br>
Then you re-run the test cases and now everything looks good. You are content about the fix, push it to Git, and close the bug. However, unexpectedly, in the near future you will find that there is still chances of OOM exception and the hprof shows the messages are still holding references to the Activity!
<br><br>
Before you become crazy it's better to take a look of the Android version of the devices with this issue. If they are older than 4.0, then this is the leak problem I will explain here.
<br><br>
Each Message object instance actually holds a reference to the Handler. When Handler.obtainMessage() is called, Android tries to get an Message object which was previously used and recycled to the message pool, and then set Message.target to the reference of the Handler. After the message is processed in Handler.handlerMessage(), the Android framework will invoke Message.recycle(), which first clears all the fields of the Message object (including Message.target), and then place it into the message pool. This mechnism makes the creation of Message instances quite proficient as the number of creation is very high. Handler.removeMessages(int) does exactly the same recycling logic on every Message object which fits for the condition.
<br><br>
So if Message.recycle() is invoked when Message objects are being placed back to message pool, or removeMessages() is called, it should be safe as the references have been cleared. Why there is still references to my activity?
<br><br>
On Android 4.0+, this issue should not happen as the framework code looks good:
{% highlight java %}
// from Android 4.0+
public class Message{
    Handler target;
    public static Message obtain(Handler h){
        Message m = obtain(); // fetch from message pool
        m.target = h;
    }
    
    public void recycle(){
        clearForRecycle();
        // place this Message into pool
    }
    
    public void clearForRecycle(){
        this.target = null;
        // clear other fields
    }
}
{% endhighlight %}
<br><br>
However, before 4.0, the relevant code looks a little bit different but the impact is not little:
{% highlight java %}
// before Android 4.0
public class Message{
    // other code is identical
    public void recycle(){
        if(mPoolSize < MAX_POOL_SIZE){}
            clearForRecycle();
            // ...
        }
    }
}
{% endhighlight %}
<br><br>
If the pool is full, then clearForRecycle() will not be executed at all! This will leave your Message objects holding reference to the Handler. As the Handler object is an inner class of MyActivity, then it holds an implicity reference to it, which prevents the activity and the whole view tree from being GC. Android team seems to be aware of this bug so they fixed it in 4.0 (may be 3.0+, but the code of Android 3.0 is not opened so I don't know).

<br><br>
My suggestion is to use static inner class for the Handler. Inside the Handler, use WeakReference to Activity. Then whatever kind of bugs there may be, your code are safe and memory leak will be prevented.
