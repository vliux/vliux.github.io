---
layout: post
title:  "Cache layout whenever you can"
date:   2014-10-30 20:45:00
categories: Android
---

On Instagram I share the my drawings comics to friends and public folks, as well as enjoying beautiful images from others. It's one of my most frequenlty used apps.
<br><br>

Recently one of my friends has made an Android application (I will call it 'SomeApp') similar to Instagram, mostly the home page, where there is a ListView showing multiple images with related comments below. However, the performance of the two differs greatly --- while the scrolling in Instagram is smooth and fast, scrolling in 'SomeApp' is laggy in which I can feel the obvious lost of frames.
<br><br>

Then I decided to make a profiling of the two apps, to find the root cause of the performance hotspot. Systrace is used to get a brief view of this difference.
<br><br>
SomeApp, Surfaceflinger process:
<img src='/images/gallery/systrace_someapp.jpg' alt='Surfaceflinger of SomeApp' width='{{ site.data.vliux.imgwidth}}'/>
<br><br>
Instagram, Surfaceflinger process:
<img src='/images/gallery/systrace_instagram.jpg' alt='Surfaceflinger of Instagram' width='{{ site.data.vliux.imgwidth}}'/>
You can see Instagram does mostly well, but for SomeApp, a lot of frames are lost.

Systrace provides a general view but didn't give much detail on the method invokation level, so I need to use TraceView. You can sort the trace results by CPU time or Real time, both inclusive or exclusive. If your case involves multi-process issue, it's better to sort by Real time, which counts the context waiting time. In my scenario most of the executions are on main thread, so sorting by CPU time should be just good.
<br><br>

I started at the most expensive inclusive CPU time method, which was Handler.dispatchMessage(), and traced downward with mostly time-consuming sub-routines layer by layer. Finally I reached our project code: 
<br>
Handler.dispatchMessage() --> ... --> ListView.makeAndAddView() --> ... AbsListView.obtainView() -->  HeaderViewListAdapter.getView() --> com.our.adapter.SomeAdapter.getView() 
<br><br>
SomeAdapter.getView() consumes 10% of the total time; while on Instagram side adapter.getView() costs less 4% of the time.
<br><br>

After getting deeper into the implementation of SomeAdapter.getView(), I finally found the root cause. Obviously the developer understood how to avoid unneccessary layout inflation by using ViewHolder. In SomeApp, each item view of the ListView consists of: an ImageView, a custom ViewGroup (called FavorListLayout)inherited from LinearLayout containing a list of small icons of the people who 'like' this image, and a custom ViewGroup (called CommentsListLayout) inheried from LinearLayout as well showing the comments posted for the image. While FavorListLayout and CommentsListLayout themselves are indeed reused, the contents inside the two custom layouts are not.
<br><br>
{% highlight java %}
public class SomeAdapter{
    public View getView(int position, View convertView, ){
        FavorListLayout favorList = null;
        CommentsListLayout commentsList = null;
        // reusing convertView, and favorList and commentsList are refered to actual views.
        favorList.setData(someData);
        commentsList.setData(someOtherData);
    }
}

public class FavorListLayout extends LinearLayout{
    public void setData(SomeData data){
        removeAllViews();
        for(Fav fav : data.getFavorList()){
            View favorView = LayoutInflater.from(getContext()).inflate(R.layout.favorlist_favorview, null); // inlate() called
            // set properties of favorView.
            addView(favorView);
        }
    }
}
{% endhighlight %}

Normally a FavorListLayout or CommentsListLayout contains 5-10 sub-views. So whenever SomeAdapter.getView() is called, there will be 10-20 invokation to inflate().
<br><br>

Conclusion
After revising the corresponding code by caching the sub-views inside FavorListLayout and CommentsListLayout, the average time cost of getView() decreased from 221ms to just 31ms. So if you are implementing a ViewGroup and adding/removing views are at high frequency, you need to re-design your ViewGroup, considering cache the views inside, not only avoid calling inflate(), but also avoid creating new instances of views like TextView/ImageView.
