---
layout: post
title:  "Battery monitor on user phones (part 1)"
date:   2014-12-06 19:09:00
categories: Android
---
In large scale Android application development teams, there are plenty of developers with very different background and technical knowledges. If a well-defined software quality bar has not been established and maintained properly for code commits, you may probably get an Android application released with high battery consumption and low efficiency. Sometimes, even experienced programmers may write some code which occasionaly consumes too much battery resource in some circumstance. In a result, the team will soon be immersed by a mass of complains from end users.
<br><br>

In addition to take more focus on the battery consumption during test phases, a technical mechanism is required which monitors the consumption of current application on user phones. If abnormal consumption has been detected, the monitor will collect more information and report them to a dedicated backend server. So the consumption hotspot can be identified.
<br><br>

Generally speaking the monitoring incluses three steps:
<li>1. Consumption checking: calculate the power usage of current application periodically.</li>
<li>2. Information collection: If battery consumption is high, use Xposed technology to hook some SDK framework methods. Every time the hooked methods are executed, the invoker (class, thread name, etc.) can be identified.</li>
<li>3. Reporting: Report the collected information to a backend server for analysis.</li>
<br><br>

<h3>Check battery consumption periodically</h3>
Assume that only the background consumption is interested (which is actually the most possible case, as users are much more intolerable to the battery drain when the app is at background). Implement the power consumtion calculation in a service, and then use AlarmManager to startService() repeatedly, 24 hours etc. In order to minizie the side-effect of the service, use AlarmManager.setInexactRepeating() instead of setRepeating().
<br><br>

On Android devices before 4.4 Kitkat, as the BATTERY_STATS permission is still applicable for 3rd party applications, thelogic of <a href="https://android.googlesource.com/platform/packages/apps/Settings/+/ce258caa4aa5cd1ea66b839ee7231c76fcfbc8d6/src/com/android/settings/fuelgauge/BatteryStatsHelper.java">BatteryStatsHelper</a> can be copied and applied into your application, which calculates the consumption from processes, wakelocks, WiFi traffic and sensors, not only your application, but also of all applications installed. In fact, the Helper gets the data from an Android system service named BatteryStats. As BatteryStats is a hidden class, you need to rely on Java reflection to invoke its methods and fetch field values.
<br><br>

On Android versions greater or equal to 4.4, you can use other methodologies to simulate the actual consumption. For example, get the CPU time from files in /proc. I will leave this to you to think about it.
<br><br>

With the consumpton data, a series of bars can be tested against. If any of the following bars is reached, the consumption is regarded as abnormally high. You can add any additional criteria for a stricter checking.
<li>the power consumption from application wake locks is more than 30% greater than last check.</li>
<li>the background power consumption of your application process is among the topest 5 of all the applications on the given phone.</li>
<br><br>

One thing to meantion. As only the background usage takes the attention, it's better to exclude consumption when application is at foreground interative to the user, which makes the computation much more complicate. One solution is to have a BroadcastReceiver listening to SCREEN_ON and SCREEN_OFF. When screen is turned off, calculate the current consumption data and store it as the intial state, and then schedule the AlarmManager. In each round of consumption checking, get the current data and compare it with the last data stored. When screen is on, cancel the AlarmManager. In such a way, the battery consumption during screen off is monitored, though it's not equal to the total background usage, it is still acceptable.
<br><br>

Part 2 about how to implement information collection is coming soon.


